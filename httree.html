<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Console Notes</title>
  <style>
    :root {
      --bg: #000;
      --fg: #f5f5f5;
      --muted: #9aa0a6;
      --accent: #00d1b2;
      --danger: #ff5577;
      --sel-bg: #111827;
      --border: #222;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font: 14px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      display: flex;
      min-height: 100vh;
    }
    .app {
      display: grid;
      grid-template-columns: 320px 1fr;
      grid-template-rows: auto 1fr;
      grid-template-areas:
        "header header"
        "tree editor";
      width: 100%;
    }
    header {
      grid-area: header;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
      user-select: none;
    }
    header .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    .dot.green { background: var(--accent); }
    .dot.red { background: var(--danger); }
    .kbd-hint { color: var(--muted); }

    .tree {
      grid-area: tree;
      border-right: 1px solid var(--border);
      min-width: 240px;
      overflow: auto;
      padding: 8px;
    }
    .tree ul { list-style: none; margin: 0; padding-left: 16px; }
    .tree li { margin: 2px 0; }

    .node {
      display: flex; align-items: center; gap: 8px;
      padding: 2px 6px; border-radius: 6px;
      cursor: default; user-select: none;
    }
    .node .twisty { width: 12px; display: inline-block; text-align: center; color: var(--muted); }
    .node .icon { width: 12px; display: inline-block; color: var(--muted); }
    .node .title { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .node.selected { background: var(--sel-bg); outline: 1px dashed #333; }

    .editor {
      grid-area: editor;
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-width: 0;
    }
    .status {
      padding: 6px 10px; border-bottom: 1px solid var(--border);
      display: flex; align-items: center; gap: 12px;
    }
    .status .pill { padding: 2px 8px; border: 1px solid var(--border); border-radius: 999px; color: var(--muted); }

    textarea#editorArea {
      width: 100%; height: 100%;
      background: transparent; color: var(--fg);
      border: none; outline: none; resize: none;
      padding: 12px;
      font: inherit; line-height: 1.5;
      tab-size: 2;
    }
    .footer { border-top: 1px solid var(--border); padding: 6px 10px; color: var(--muted); }

    .dim { color: var(--muted); }
    .accent { color: var(--accent); }
    .danger { color: var(--danger); }

    /* Scrollbars */
    ::-webkit-scrollbar { width: 10px; height: 10px; }
    ::-webkit-scrollbar-thumb { background: #1f2937; border-radius: 6px; }
    ::-webkit-scrollbar-track { background: #0b0f17; }
  </style>
</head>
<body>
    <div class="app">
        <header style="display: none;">
            <span class="dot green"></span>
            <strong>Console Notes</strong>
            <span class="kbd-hint">i: edit / Esc: global keys • j/k: next/prev • h/l: collapse/expand</span>
            <span class="kbd-hint">A/a: add child/after • H/L: move out/in • J/K: reorder • C/E: collapse/expand all • D: delete • r: new root • s: save</span>
        </header>

        <div id="helpDialog" style="
            display: none;
            position: fixed;
            top: 5%;
            left: 50%;
            transform: translateX(-50%);
            background: rgb(34, 34, 34);
            color: white;
            border: 2px solid #999;
            padding: 20px;
            z-index: 9999;
            font-family: monospace;
            max-width: 820px;
            text-align: left;
            box-shadow: rgb(0, 0, 0) 0px 0px 40px;">
            <h3>Key Bindings</h3>
            <p></p>
            <table style="border-collapse: collapse; border: none; width: 100%;">
                <tr>
                    <td style="vertical-align: top; padding-right: 10px;">
                        <pre>
r = Add root level node
R = Rename current Folder
j = Select the next sibling tree node
k = Select the previous sibling tree node
l = Expand the current tree node
h = Collapse the current tree node
C = Collapse all the tree nodes
E = Expand all the tree nodes
                        </pre>
                    </td>
                    <td style="vertical-align: top; padding-left: 10px;">
                        <pre>
A = Add child tree node
a = Add next sibling tree node
H = Move current node to the parent node
L = Make current node a child node
J = Move current node down
K = Move current node up
D = Delete the current node
s = Save the current file
                        </pre>
                    </td>
                </tr>
            </table>
            <p></p>
            <p>
                <a href="https://vummel.tiddlyhost.com" target="_blank" style="color: #fff; text-decoration: underline;">
                    Full Documentation
                </a>
            </p>
            <p>Press ESC to close.</p>
        </div>

        <aside class="tree" id="tree"></aside>

    <section class="editor">
      <div class="status">
        <span id="path" class="dim">/</span>
        <span id="mode" class="pill">NORMAL</span>
        <span id="kind" class="pill">FOLDER</span>
      </div>
      <textarea id="editorArea" spellcheck="false" placeholder="Press 'i' to edit note…"></textarea>
      <div class="footer">Tip: Capital-letter commands are matched by the actual letter (e.g., press the key to get 'C'); we do not depend on Shift — Caps Lock also works.</div>
    </section>
  </div>

  <script>
  // ------------------------ Data Model ------------------------
  const makeId = () => Math.random().toString(36).slice(2, 10);

  /** @typedef {{ id:string, title:string, content:string, children:NodeT[], expanded:boolean }} NodeT */

  /** @type {NodeT[]} */
  let treeData = [];
  let selectedId = null;
  let editing = false;

  // ------------------------ Utilities ------------------------
  function generateId() {
    return Math.random().toString(36).substr(2, 9);
  }
  function findNode(id) {
    for (const n of treeData) {
        if (n.id === id) return n;
    }
  }
  function findNodeAndParentById(id, nodes = treeData, parent = null) {
    for (const n of nodes) {
      if (n.id === id) return { node: n, parent };
      const res = findNodeAndParentById(id, n.children, n);
      if (res) return res;
    }
    return null;
  }
  function getSiblingsAndIndex(id) {
    const info = findNodeAndParentById(id);
    if (!info) return null;
    const siblings = info.parent ? info.parent.children : treeData;
    const index = siblings.findIndex(n => n.id === id);
    return { siblings, index, parent: info.parent };
  }
  function isFolder(n){ return (n.content || "").trim().length === 0; }
  function updateTitleFromContent(n){
    const firstLine = (n.content||"").split(/\r?\n/)[0].trim();
    if (firstLine) n.title = firstLine.slice(0, 80);
    else if (!n.title || !n.title.startsWith("New")) n.title = "New Folder";
  }
  function computePath(id){
    const segments = [];
    (function walk(id){
      const info = findNodeAndParentById(id);
      if (!info) return;
      if (info.parent) walk(info.parent.id);
      segments.push(info.node.title || "Untitled");
    })(id);
    return '/' + segments.join('/');
  }

  // ------------------------ Rendering ------------------------
  const treeEl = document.getElementById('tree');
  const editorArea = document.getElementById('editorArea');
  const modeEl = document.getElementById('mode');
  const kindEl = document.getElementById('kind');
  const pathEl = document.getElementById('path');

  function render(){
    // Render tree
    treeEl.innerHTML = '';
    const ul = document.createElement('ul');
    treeEl.appendChild(ul);

    function renderNode(n){
      const li = document.createElement('li');
      const row = document.createElement('div');
      row.className = 'node' + (n.id === selectedId ? ' selected' : '');

      // Twisty indicator
      const twist = document.createElement('span');
      twist.className = 'twisty';
      twist.textContent = n.children.length ? (n.expanded ? '▾' : '▸') : '·';

      // Icon
      const icon = document.createElement('span');
      icon.className = 'icon';
      icon.textContent = isFolder(n) ? '📁' : '📄';

      const title = document.createElement('span');
      title.className = 'title';
      title.textContent = n.title || '(untitled)';

      row.appendChild(twist); row.appendChild(icon); row.appendChild(title);
      row.addEventListener('click', () => { selectedId = n.id; render(); });

      li.appendChild(row);

      if (n.expanded && n.children.length){
        const inner = document.createElement('ul');
        for (const c of n.children) inner.appendChild(renderNode(c));
        li.appendChild(inner);
      }
      return li;
    }

    for (const n of treeData) ul.appendChild(renderNode(n));

    // Render editor status + content
    const selInfo = findNodeAndParentById(selectedId);
    if (selInfo){
      pathEl.textContent = computePath(selInfo.node.id);
      kindEl.textContent = isFolder(selInfo.node) ? 'FOLDER' : 'FILE';
      if (!editing) {
        editorArea.value = selInfo.node.content || '';
        editorArea.setAttribute('readonly', 'readonly');
      } else {
        editorArea.removeAttribute('readonly');
        // keep as-is while editing
      }
    } else {
      pathEl.textContent = '/';
      kindEl.textContent = '—';
      editorArea.value = '';
      editorArea.setAttribute('readonly', 'readonly');
    }

    modeEl.textContent = editing ? 'INSERT' : 'NORMAL';
  }

  // ------------------------ Editor Sync ------------------------
  editorArea.addEventListener('input', () => {
    const info = findNodeAndParentById(selectedId);
    if (!info) return;
    info.node.content = editorArea.value;
    updateTitleFromContent(info.node);
    // File vs folder might have changed; keep UI responsive
    render();
  });

  editorArea.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      e.preventDefault();
      editing = false;
      editorArea.blur();
      render();
    }
  });

  // ------------------------ Commands ------------------------
  function ensureSelection(){ if (!selectedId && treeData[0]) selectedId = treeData[0].id; }

  function addRoot(){
    const node = { id: makeId(), title: 'New Folder', content: '', children: [], expanded: true };
    treeData.push(node);
    selectedId = node.id;
  }
  function addAfter(){
    ensureSelection();
    const ctx = getSiblingsAndIndex(selectedId);
    if (!ctx) return;
    const node = { id: makeId(), title: 'New Folder', content: '', children: [], expanded: true };
    ctx.siblings.splice(ctx.index + 1, 0, node);
    selectedId = node.id;
  }
  function addChild(){
    ensureSelection();
    const info = findNodeAndParentById(selectedId);
    if (!info) return;
    info.node.expanded = true;
    const node = { id: makeId(), title: 'New Folder', content: '', children: [], expanded: true };
    info.node.children.push(node);
    selectedId = node.id;
  }
  function renameFolder() {
    ensureSelection();
    let selectedNode = findNodeAndParentById(selectedId).node;
    if (isFolder(selectedNode)) {
        let newName = prompt('Enter new folder name:', selectedNode.name);
        if (!newName) { return; }
        selectedNode.title = newName;
        render();
    }
  }
  function selectNextSibling(){
    const ctx = getSiblingsAndIndex(selectedId); if (!ctx) return;
    const next = Math.min(ctx.index + 1, ctx.siblings.length - 1);
    selectedId = ctx.siblings[next].id;
  }
  function selectPrevSibling(){
    const ctx = getSiblingsAndIndex(selectedId); if (!ctx) return;
    const prev = Math.max(ctx.index - 1, 0);
    selectedId = ctx.siblings[prev].id;
  }
  function expandOrFirstChild(){
    const info = findNodeAndParentById(selectedId); if (!info) return;
    if (info.node.children.length && !info.node.expanded) {
      info.node.expanded = true;
    } else if (info.node.children.length) {
      selectedId = info.node.children[0].id;
    }
  }
  function collapseCurrent(){
    const info = findNodeAndParentById(selectedId); if (!info) return;
    if (info.node.expanded) info.node.expanded = false; else if (info.parent) selectedId = info.parent.id;
  }
  function collapseAll(){
    (function walk(list){
      for (const n of list){ n.expanded = false; walk(n.children); }
    })(treeData);
  }
  function expandAll(){
    (function walk(list){
      for (const n of list){ n.expanded = true; walk(n.children); }
    })(treeData);
  }
  function moveOutToParent(){
    const ctx = getSiblingsAndIndex(selectedId); if (!ctx || !ctx.parent) return; // already root
    // Remove from current siblings
    const [node] = ctx.siblings.splice(ctx.index, 1);
    // Insert after parent in its own siblings list
    const pctx = getSiblingsAndIndex(ctx.parent.id);
    const insertAt = pctx.index + 1;
    pctx.siblings.splice(insertAt, 0, node);
    selectedId = node.id;
  }
  function moveIntoAsChild(){
    const info = findNodeAndParentById(selectedId); if (!info) return;
    // Move selected under some other selected? Spec: 'L' moves the current node into the currently selected node, as a child.
    // Since there's only one selection, interpret as: move the node into its next sibling if any; else do nothing.
    // Better: if the node has a previous sibling, move it into that sibling (common Vim tree behavior with L)?
    // But spec says: into the currently selected node — that's the node itself; so allow moving the PREVIOUS sibling into CURRENT with hotkey on that previous sibling would be impossible.
    // We'll interpret L as: if there is a previous sibling, move this node into that previous sibling as a child; otherwise if current has a next sibling, move into that. If neither, no-op.

    const ctx = getSiblingsAndIndex(selectedId); if (!ctx) return;
    const target = ctx.siblings[ctx.index - 1] || ctx.siblings[ctx.index + 1];
    if (!target) return;
    if (!Array.isArray(target.children)) target.children = [];
    target.expanded = true;
    const [node] = ctx.siblings.splice(ctx.index, 1);
    target.children.push(node);
    selectedId = node.id;
  }
  function reorderAmongSiblings(dir){
    const ctx = getSiblingsAndIndex(selectedId); if (!ctx) return;
    const newIndex = ctx.index + (dir === 'down' ? 1 : -1);
    if (newIndex < 0 || newIndex >= ctx.siblings.length) return;
    const [node] = ctx.siblings.splice(ctx.index, 1);
    ctx.siblings.splice(newIndex, 0, node);
    selectedId = node.id;
  }
  function deleteNode(){
    const ctx = getSiblingsAndIndex(selectedId); if (!ctx) return;
    const goTo = ctx.siblings[ctx.index + 1] || ctx.siblings[ctx.index - 1] || ctx.parent || treeData[0] || null;
    ctx.siblings.splice(ctx.index, 1);
    selectedId = goTo ? (goTo.id || goTo) : null;
  }




function saveAsHtml() {
const name = prompt("Save as .html (enter name without extension):", "");
if (!name) return;

            const elemLimit = 20; // Number of elements per line
            const htmlDoc = document.documentElement.cloneNode(true);

            // Make sure the latest database is stored
            const latestDatabase = JSON.parse(JSON.stringify(treeData));

            const lines = [];
            for (let i = 0; i < latestDatabase.length; i += elemLimit) {
                let chunk = latestDatabase.slice(i, i + elemLimit);
                lines.push(JSON.stringify(chunk).slice(1, -1)); // Strip [ and ]
            }
            let formattedDatabase = `[\n  ${lines.join(",\n  ")}\n]`;

            // Ensure correct replacement of the old database
            let htmlContent = "<!DOCTYPE html>" + htmlDoc.outerHTML;
            htmlContent = htmlContent.replace(/let\s+treeData\s*=\s*\[[\s\S]*?\];/, `let treeData = ${formattedDatabase};`);

            let blob = new Blob([htmlContent], { type: "text/html" });
            let a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = `${name}.html`;
            a.click();
}




  // ------------------------ Key Handling ------------------------
  function handleGlobalKey(e){
    if (editing) return; // only when not editing
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    const k = e.key; // compare exact letter; do not rely on shift state
    let did = true;
    switch (k) {
      case 'i':
        const info = findNodeAndParentById(selectedId); if (!info) return;
        editing = true; render(); editorArea.focus(); editorArea.setSelectionRange(editorArea.value.length, editorArea.value.length);
        break;
      case 'Escape': did = false; break; // handled in textarea
      case 'r': addRoot(); break;
      case 'R': renameFolder(); break;
      case 'j': selectNextSibling(); break;
      case 'k': selectPrevSibling(); break;
      case 'l': expandOrFirstChild(); break;
      case 'h': collapseCurrent(); break;
      case 'C': collapseAll(); break;
      case 'E': expandAll(); break;
      case 'A': addChild(); break;
      case 'a': addAfter(); break;
      case 'H': moveOutToParent(); break;
      case 'L': moveIntoAsChild(); break;
      case 'J': reorderAmongSiblings('down'); break;
      case 'K': reorderAmongSiblings('up'); break;
      case 'D': deleteNode(); break;
      case 's': saveAsHtml(); break;
      default: did = false; break;
    }
    if (did) { e.preventDefault(); render(); }
  }

    document.addEventListener('keydown', e => {
        if (e.key === '?' && !editing) {
            document.getElementById('helpDialog').style.display = 'block';
            e.preventDefault();
            return;
        }

        if (e.key === 'Escape') {
            repeatCount = 1;

            if (document.getElementById('helpDialog').style.display === 'block') {
                document.getElementById('helpDialog').style.display = 'none';
                e.stopPropagation();
                return;
            } else {
                selectedNode = null;
                setSelectedNode(null);
            }
        }
    });

  window.addEventListener('keydown', handleGlobalKey, { capture: true });

  // ------------------------ Save-as-HTML (self-contained) ------------------------
  function escapeForScript(json){
    return json.replace(/<\//g, '<\\/'); // avoid closing script tags
  }
  // ------------------------ Init ------------------------
window.addEventListener('load', function() {
    render();
    selectedId = treeData[0]?.id || null;
});
  </script>
</body>
</html>
