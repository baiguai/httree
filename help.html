<!DOCTYPE html>
<html><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Httree</title>
<style>
        :root {
            --bg: #000;
            --fg: #f5f5f5;
            --muted: #9aa0a6;
            --accent: #00d1b2;
            --danger: #ff5577;
            --sel-bg: #111827;
            --border: #222;
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font: 14px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            display: flex;
            min-height: 100vh;
        }
        .app {
            display: grid;
            grid-template-columns: 320px 1fr;
            grid-template-rows: auto 1fr;
            grid-template-areas:
            "header header"
            "tree editor";
            width: 100%;
        }
        header {
            grid-area: header;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 12px;
            user-select: none;
        }
        header .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
        .dot.green { background: var(--accent); }
        .dot.red { background: var(--danger); }
        .kbd-hint { color: var(--muted); }

        .tree {
            grid-area: tree;
            border-right: 1px solid var(--border);
            min-width: 240px;
            overflow: auto;
            padding: 8px;
        }
        .tree ul { list-style: none; margin: 0; padding-left: 16px; }
        .tree li { margin: 2px 0; }

        .node {
            display: flex; align-items: center; gap: 8px;
            padding: 2px 6px; border-radius: 2px;
            cursor: default; user-select: none;
        }
        .node .twisty { width: 12px; display: inline-block; text-align: center; color: var(--muted); }
        .node .icon { width: 16px; height: 16px; display: inline-block; color: var(--muted); }
        .node .title { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .node.selected { background: var(--sel-bg); outline: 1px dashed #333; }

        .editor {
            grid-area: editor;
            display: grid;
            grid-template-rows: auto 1fr auto;
            min-width: 0;
        }
        .status {
            padding: 6px 10px; border-bottom: 1px solid var(--border);
            display: flex; align-items: center; gap: 12px;
        }
        .status .pill { padding: 2px 8px; border: 1px solid var(--border); border-radius: 999px; color: var(--muted); }

        textarea#editorArea {
            width: 100%; height: 100%;
            background: transparent; color: var(--fg);
            border: none; outline: none; resize: none;
            padding: 12px;
            font: inherit; line-height: 1.5;
            tab-size: 2;
        }
        .footer { border-top: 1px solid var(--border); padding: 6px 10px; color: var(--muted); }

        .dim { color: var(--muted); }
        .accent { color: var(--accent); }
        .danger { color: var(--danger); }

        /* Searching */
        .search-dialog {
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            max-height: 70%;
            overflow: hidden;
            background: #222;
            color: #fff;
            border: 2px solid #444;
            border-radius: 2px;
            z-index: 9999;
            font-family: monospace;
            padding: 10px;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
        }
        .search-dialog input {
            padding: 5px;
            margin-bottom: 10px;
            background: #111;
            color: #fff;
            border: 1px solid #555;
            width: 100%;
        }
        .search-results {
            overflow-y: auto;
            flex: 1;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
        }
        .search-results div {
            padding: 5px 8px;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .search-results div.selected {
            background: #444;
        }

        /* Links Dialog */
        #linksDialog {
            display: none;
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            max-height: 70%;
            background: #222;
            color: #fff;
            border: 2px solid #444;
            border-radius: 2px;
            padding: 20px;
            z-index: 9999;
            font-family: monospace;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }
        #linksDialog h3 {
            margin-top: 0;
        }
        #linksList a {
            display: block;
            color: #00d1b2;
            text-decoration: underline;
            margin-bottom: 6px;
            word-break: break-all;
        }
        #linksDialog .close {
            margin-top: 10px;
            color: #ccc;
            cursor: pointer;
            display: inline-block;
        }

        /* Search/Replace Dialog */
        #replaceDialog {
            display: none;
            position: fixed;
            top: 15%;
            left: 5px;
            /* transform: translateX(-50%); */
            width: 230px;
            background: #222;
            color: #fff;
            border: 2px solid #444;
            border-radius: 2px; /* per your request */
            padding: 16px;
            z-index: 9999;
            font-family: monospace;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }
        #replaceDialog h3 {
            margin-top: 0;
        }
        #replaceDialog label {
            display: block;
            margin-bottom: 4px;
        }
        #replaceDialog input {
            width: 100%;
            padding: 6px;
            margin-bottom: 10px;
            background: #111;
            color: #fff;
            border: 1px solid #555;
        }
        #replaceDialog button {
            background: #444;
            color: #ddd;
            border: none;
            padding: 6px 12px;
            margin-right: 8px;
            cursor: pointer;
            font-family: inherit;
        }
        #replaceDialog .close {
            background: #444;
            color: #fff;
        }


        /* Scrollbars */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-thumb { background: #1f2937; border-radius: 2px; }
        ::-webkit-scrollbar-track { background: #0b0f17; }
    
    #linksList a.selected {
        background: #444;
        display: block;
    }
    </style>
<style id="operaUserStyle" type="text/css"></style></head>
<body>
<div class="app" style="grid-template-columns: 320px 1fr;">
<header style="display: none;">
<span class="dot green"></span>
<strong>Console Notes</strong>
<span class="kbd-hint">i: edit / Esc: global keys • j/k: next/prev • h/l: collapse/expand</span>
<span class="kbd-hint">A/a: add child/after • H/L: move out/in • J/K: reorder • C/E: collapse/expand all • D: delete • r: new root • s: save</span>
</header>
<div id="helpDialog" style="display: none; position: fixed; top: 5%; left: 50%; transform: translateX(-50%); background: rgb(34, 34, 34); color: white; border: 2px solid rgb(153, 153, 153); padding: 20px; z-index: 9999; font-family: monospace; max-width: 820px; text-align: left; box-shadow: rgb(0, 0, 0) 0px 0px 40px;">
<h3>Key Bindings</h3>
<p></p>
<table id="authorHelp" style="border-collapse: collapse; border: medium; width: 100%; display: block;">
<tbody><tr>
<td style="vertical-align: top; padding-right: 10px;">
<pre>r = Add root level node
R = Rename current Folder
j = Select the next tree node
k = Select the previous tree node
, = Select the next sibling tree node
. = Select the previous sibling tree node
l = Expand the current tree node
h = Collapse the current tree node
C = Collapse all the tree nodes
E = Expand all the tree nodes
A = Add child tree node
a = Add next sibling tree node
] = Expand the treeview panel
[ = Shrink the treeview panel
g = Select top tree node
G = Select bottom tree node
</pre>
</td>
<td style="vertical-align: top; padding-left: 10px;">
<pre>H = Move current node to the parent node
L = Make current node a child node
J = Move current node down
K = Move current node up
D = Delete the current node
i = Edit current note
/ = Search (begin with : to search labels)
f = Find/Replace text in the current note 
# = Show note links dialog
< = Show the history dialog
X = Show broken note links

s = Save the current file
S = Save as
</pre>
</td>
</tr>
</tbody></table>
<pre id="readerHelp" style="display: none;">
j = Select the next tree node
k = Select the previous tree node
, = Select the next sibling tree node
. = Select the previous sibling tree node
l = Expand the current tree node
h = Collapse the current tree node
C = Collapse all the tree nodes
E = Expand all the tree nodes
] = Expand the treeview panel
[ = Shrink the treeview panel
/ = Search (begin with : to search labels)
f = Find text in the current note 
# = Show note links dialog
< = Show the history dialog
g = Select top tree node
G = Select bottom tree node
</pre>
<p></p>
<p style="display: none;">
<a href="#" style="color: #fff; text-decoration: underline;" target="_blank">
                    Full Documentation
                </a>
</p>
<p>Press ESC to close.</p>
</div>
<aside class="tree" id="tree"><ul><li><div class="node selected"><span class="twisty"><svg height="6" viewbox="0 0 6 6" width="6" xmlns="http://www.w3.org/2000/svg"><circle cx="3" cy="3" fill="currentColor" r="1"></circle></svg></span><span class="icon"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?--> <!-- Created with Inkscape (http://www.inkscape.org/) --> <svg height="16" id="svg5" version="1.1" viewbox="0 0 4.2333334 4.2333334" width="16" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2"></defs> <path d="m 0.79374997,0.63637699 c 1.76898013,-0.006197 0.91709523,0 2.64583343,0 V 3.5997107 H 0.79374997 Z" id="path65" style="fill:#80a5ba;fill-opacity:1;stroke-width:1.53367;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers"></path> <path d="m 1.0583332,0.93243487 c 1.4151843,-0.004957 0.7336763,0 2.116667,0 V 3.303102 h -2.116667 z" id="path4404" style="fill:#787878;fill-opacity:1;stroke-width:1.22694;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers"></path> <rect height="0.24694447" id="rect5117" style="fill:#364750;fill-opacity:1;stroke-width:1.53367;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" width="1.0583334" x="1.5875001" y="1.3772104"></rect> <rect height="0.24694447" id="rect5737" style="fill:#364750;fill-opacity:1;stroke-width:1.53367;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" width="1.0583334" x="1.5875001" y="1.8710994"></rect> <rect height="0.24694447" id="rect5739" style="fill:#364750;fill-opacity:1;stroke-width:1.53367;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" width="1.0583334" x="1.5875001" y="2.3649883"></rect> </svg></span><span class="title">Introduction</span></div></li><li><div class="node"><span class="twisty"><svg height="10" viewbox="0 0 10 10" width="10" xmlns="http://www.w3.org/2000/svg"><path d="M3 1 L7 5 L3 9 Z" fill="currentColor"></path></svg></span><span class="icon"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?--> <svg height="16" id="svg5" version="1.1" viewbox="0 0 4.2333334 4.2333334" width="16" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2"></defs> <g id="g5951" transform="matrix(0.18666667,0,0,0.18666667,-0.22930552,-0.10583338)"> <g id="layer1"> <path d="M 2.6458333,3.96875 H 11.90625 l 2.645833,2.6458332 h 7.9375 V 19.84375 H 2.6458333 Z" id="path65" style="fill:#80a5ba;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers"></path> <path d="m 3.96875,5.2916667 h 7.408333 l 2.38125,2.38125 h 7.408334 V 18.520833 H 3.96875 Z" id="path924" style="fill:#466779;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers"></path> <rect height="9.260417" id="rect1561" style="fill:#364750;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" width="17.197916" x="3.96875" y="9.260417"></rect> </g> </g> </svg></span><span class="title">The Interface</span></div></li><li><div class="node"><span class="twisty"><svg height="10" viewbox="0 0 10 10" width="10" xmlns="http://www.w3.org/2000/svg"><path d="M3 1 L7 5 L3 9 Z" fill="currentColor"></path></svg></span><span class="icon"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?--> <svg height="16" id="svg5" version="1.1" viewbox="0 0 4.2333334 4.2333334" width="16" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2"></defs> <g id="g5951" transform="matrix(0.18666667,0,0,0.18666667,-0.22930552,-0.10583338)"> <g id="layer1"> <path d="M 2.6458333,3.96875 H 11.90625 l 2.645833,2.6458332 h 7.9375 V 19.84375 H 2.6458333 Z" id="path65" style="fill:#80a5ba;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers"></path> <path d="m 3.96875,5.2916667 h 7.408333 l 2.38125,2.38125 h 7.408334 V 18.520833 H 3.96875 Z" id="path924" style="fill:#466779;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers"></path> <rect height="9.260417" id="rect1561" style="fill:#364750;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" width="17.197916" x="3.96875" y="9.260417"></rect> </g> </g> </svg></span><span class="title">Saving</span></div></li><li><div class="node"><span class="twisty"><svg height="10" viewbox="0 0 10 10" width="10" xmlns="http://www.w3.org/2000/svg"><path d="M3 1 L7 5 L3 9 Z" fill="currentColor"></path></svg></span><span class="icon"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?--> <svg height="16" id="svg5" version="1.1" viewbox="0 0 4.2333334 4.2333334" width="16" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2"></defs> <g id="g5951" transform="matrix(0.18666667,0,0,0.18666667,-0.22930552,-0.10583338)"> <g id="layer1"> <path d="M 2.6458333,3.96875 H 11.90625 l 2.645833,2.6458332 h 7.9375 V 19.84375 H 2.6458333 Z" id="path65" style="fill:#80a5ba;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers"></path> <path d="m 3.96875,5.2916667 h 7.408333 l 2.38125,2.38125 h 7.408334 V 18.520833 H 3.96875 Z" id="path924" style="fill:#466779;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers"></path> <rect height="9.260417" id="rect1561" style="fill:#364750;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" width="17.197916" x="3.96875" y="9.260417"></rect> </g> </g> </svg></span><span class="title">Configuration</span></div></li><li><div class="node"><span class="twisty"><svg height="10" viewbox="0 0 10 10" width="10" xmlns="http://www.w3.org/2000/svg"><path d="M3 1 L7 5 L3 9 Z" fill="currentColor"></path></svg></span><span class="icon"><!--?xml version="1.0" encoding="UTF-8" standalone="no"?--> <svg height="16" id="svg5" version="1.1" viewbox="0 0 4.2333334 4.2333334" width="16" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2"></defs> <g id="g5951" transform="matrix(0.18666667,0,0,0.18666667,-0.22930552,-0.10583338)"> <g id="layer1"> <path d="M 2.6458333,3.96875 H 11.90625 l 2.645833,2.6458332 h 7.9375 V 19.84375 H 2.6458333 Z" id="path65" style="fill:#80a5ba;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers"></path> <path d="m 3.96875,5.2916667 h 7.408333 l 2.38125,2.38125 h 7.408334 V 18.520833 H 3.96875 Z" id="path924" style="fill:#466779;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers"></path> <rect height="9.260417" id="rect1561" style="fill:#364750;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" width="17.197916" x="3.96875" y="9.260417"></rect> </g> </g> </svg></span><span class="title">Linking</span></div></li></ul></aside>
<section class="editor">
<div class="status">
<span class="dim" id="path">/Introduction</span>
<span class="pill" id="mode" style="display: block;">NORMAL</span>
<span class="pill" id="kind">FILE</span>
</div>
<textarea id="editorArea" readonly="readonly" spellcheck="false"></textarea>
</section>
</div>
<div class="search-dialog" id="searchDialog" style="display: none;">
<input id="searchInput" placeholder="Search..." type="text"/>
<div class="search-results" id="searchList"><div>Resizing the Tree Panel</div><div class="selected">Introduction to Saving</div><div>Save</div><div>Save As</div></div>
</div>
<div id="linksDialog" style="display: none;">
<h3>Links in Note</h3>
<div id="linksList"><a href="#">Persistent Settings</a><br/></div>
</div>
<div id="replaceDialog" style="display: none;">
<h3>Find &amp; Replace</h3>
<label for="searchText">Find</label>
<input id="searchText" type="text"/>
<div id="replaceTools" style="display: block;">
<label for="replaceText">Replace With</label>
<input id="replaceText" type="text"/>
<div style="display: none;">
<button onclick="doFind()">Find</button>
<button onclick="doReplaceAll()">Replace All</button>
</div>
</div>
<div id="replaceResults">Match 1 of 1</div>
</div>

<div id="historyDialog" style="display: none; position: fixed; top: 10%; left: 50%; transform: translateX(-50%);
    width: 600px; max-height: 70%; background: #222; color: #fff; border: 2px solid #444;
    border-radius: 2px; padding: 20px; z-index: 9999; font-family: monospace; overflow-y: auto;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);">
  <h3>History</h3>
  <div id="historyList"></div>
</div>

<script>
        //---- Data Model ------------------------------------------------------
        const makeId = () => Math.random().toString(36).slice(2, 10);

        /** @typedef {{ id:string, title:string, content:string, children:NodeT[], expanded:boolean }} NodeT */

        /** @type {NodeT[]} */
        let treeData = [
  {"id":"7tvrov2y","title":"Introduction","content":"Introduction\n--------------------------------------------------------------------------------\n\nHttree is a plain text editor that is a stand alone HTML file. It is fully\nkeyboard driven. To quickly access the key-bindings press: ?\n\nIf you are familiar with VIM key-bindings you should find Httree fairly\ncomfortable, however these are used when not editing a note. They are used\nto manage your collection of notes - navigating the treeview, editing tree\nnodes, activating searches within the tree or the currently selected note,\nas well as finding and replacing text within the note (you will want to consult\nthe _Find and Replace_ topic, there is some 'hidden' functionality there).\n\nBeing a stand alone HTML file, saving doesn't behave as a typical application\nwould so be sure to consult the _Saving_ topic.\n\n\nCompatibility\n--------------------------------------------------------------------------------\n\nBeing a stand alone HTML file, Httree can be used on any device with a\nJavascript-enabled web browser on it. However virtual keyboards (like those\nfound on mobile phones) may be problematic. This is because they are typically\nonly visible when a text field is selected - and because they generally lack\nan escape key. However if you have a tablet with a physical keyboard, Httree\nSHOULD work fine for you.","children":[],"expanded":false},{"id":"14cvysn7","title":"The Interface","content":"","children":[{"id":"7qkwy1zi","title":"The Parts of the Interface","content":"","children":[{"id":"8a3baq8g","title":"The Treeview","content":"The Treeview\n--------------------------------------------------------------------------------\n\nIn Httree you can organize your notes or topics etc into a treeview structure.\nThe tree is found in the left side panel of the interface. This panel can\nbe resized as needed (refer to the _Resizing the Tree Panel_ topic).","children":[],"expanded":false},{"id":"eecjyull","title":"The Information Panel","content":"The Information Panel\n--------------------------------------------------------------------------------\n\nYou will notice that above the editor area there is an information panel.\nThis shows you:\n\n* The treeview path to the currently selected node.\n* Whether you are in INSERT (note edit) mode, or NORMAL mode.\n* The type of the currently selected node.","children":[],"expanded":false},{"id":"l3ycmf97","title":"The Editor Panel","content":"The Editor Panel\n--------------------------------------------------------------------------------\n\nThe editor panel is the primary area in the right side of the interface.\nThis is where you will enter all of your notes/topics/files text.\nTo edit this text, use the i key when not in INSERT mode.","children":[],"expanded":false}],"expanded":false},{"id":"0t196wlf","title":"Treeview","content":"","children":[{"id":"cebifb4d","title":"Introduction to the Treeview","content":"Introduction to the Treeview\n--------------------------------------------------------------------------------\n\nHttree uses a treeview to organize your notes. You can create, move, rename,\nexpand/collapse nodes, and delete them using key-bindings. To see what those\nare use the ? key.\n\nAlthough each binding is explained here be aware that Httree is still being\nexpanded and improved so there may be additional bindings not noted yet so\nusing ? is a good idea to ensure you are aware of ALL the bindings.","children":[],"expanded":false},{"id":"kbar9bmx","title":"Notes Versus Folders","content":"Notes Versus Folders\n--------------------------------------------------------------------------------\n\nWhen tree nodes are created they are initially folders. If there is any text\npresent in that node it becomes a note (or file) node. You can revert it back\nto a folder node by delete all the text in the node's note.\n\nThe first line of text in a note node's note becomes the node's label, so\nto rename it simply change the first line of text in the note.","children":[],"expanded":false},{"id":"sa6zi82h","title":"Renaming Nodes","content":"Renaming Nodes\n--------------------------------------------------------------------------------\n\nThere are two different types of nodes in Httree: Folder nodes and File (or\nnote) nodes.\n\n\nRenaming Folder Nodes\nTo rename folder nodes use the key-binding: R\nThis will pop up a dialog for you to specify the new label, then hit Enter.\n\nRenaming File Nodes\nFile nodes use the first line of text within the note. So to rename those\nnodes, change the first line in the node's note.","children":[],"expanded":false},{"id":"d1wmxk91","title":"Deleting Nodes","content":"Deleting Nodes\n--------------------------------------------------------------------------------\n\nKey Binding: D\n\nUsing the D key allows you to delete the currently selected node.\n\n** Warning! **\nThis cannot be undone. HOWEVER! Consult the topics on _Saving_, because it\nMAY be possible to roll it back, depending on your saving habits.","children":[],"expanded":false},{"id":"dawlh4vo","title":"Resizing the Tree Panel","content":"Resizing the Tree Panel\n--------------------------------------------------------------------------------\n\nKey Binding: ]\n\nIf you use the ] key, it will make the treeview panel larger.\n\n** Note **\nBe sure to consult the _Saving_ topics, there are changes - including\nmodifications to the tree panel width that are stored when you save your\nHttree notes.","children":[],"expanded":false},{"id":"einv7fsw","title":"Adding Nodes","content":"","children":[{"id":"2wy2kc0h","title":"Adding Root Nodes","content":"Adding Root Nodes\n--------------------------------------------------------------------------------\n\nKey Binding: r\n\nWhen you aren't editing a note and you press the r key, a new root level\nnode is created within the tree.\n\n\n** Remember **\nTree nodes can easily be moved up or down and in and out of other tree nodes.\nConsult the _Navigation_ topics or view the key-bindings with ?","children":[],"expanded":false},{"id":"s39xlsla","title":"Adding Child Nodes","content":"Adding Child Nodes\n--------------------------------------------------------------------------------\n\nKey Binding: A\n\nWhen you have a node selected (even if it is a file node) you can add a child\nnode by using the A key. However remember that moving nodes in and out of\nother nodes is very easy to do in Httree so don't worry if you inadvertently\ncreate a node in the wrong place.","children":[],"expanded":false},{"id":"b3wf7fsh","title":"Adding Sibling Nodes","content":"Adding Sibling Nodes\n--------------------------------------------------------------------------------\n\nKey Binding: a\n\nTo add a sibling node below the currently selected node use the a key. This\neven works at the root level! So once you have one root node you can use\neither r or if a root node is currently selected you can use a.","children":[],"expanded":false}],"expanded":false},{"id":"xt56a250","title":"Navigation","content":"","children":[{"id":"2e6rgjdn","title":"Introduction to Navigation","content":"Introduction to Navigation\n--------------------------------------------------------------------------------\n\nIt is important to note that navigation is handled per node level. That is\nif you are navigating up and down among the children of another node, this\nwill not move you out of that parent node (if you continue to move up when\nthe first child is selected). You will want to use the left and right\nnavigation keys to enter or exit a node.","children":[],"expanded":false},{"id":"dus9eopn","title":"Moving Up and Down","content":"Moving Up and Down\n--------------------------------------------------------------------------------\n\nKey Bindings: k j\n\nMoving Up:\nTo move up through the nodes at the currently selected level of the treeview,\nuse the k key. This will only navigate within the current node's children (or\namong the root nodes if you are at that level). To move in or out of folders\nuse the left and right navigation keys.\n\nMoving Down:\nTo move down through the nodes, use the j key.","children":[],"expanded":false},{"id":"7stxmz4r","title":"Moving Left and Right","content":"Moving Left and Right\n--------------------------------------------------------------------------------\n\nKey Bindings: h l\n\nMoving Left:\nTo move left (rather to select the current node's parent node), use the h key.\n\nMoving Right:\nTo move into a child node (to move right), use the l key.","children":[],"expanded":false},{"id":"f3zxnip3","title":"Selecting 'Root' Node","content":"Selecting 'Root' Node\n--------------------------------------------------------------------------------\n\nThere is a trick that will allow you to quickly select the topmost root node\nin your tree - use the collapse all key-binding: C","children":[],"expanded":false}],"expanded":false},{"id":"rdhoauja","title":"Expanding and Collapsing","content":"","children":[{"id":"cxrglw4i","title":"Introduction to Expanding/Collapsing","content":"Introduction to Expanding/Collapsing\n--------------------------------------------------------------------------------\n\nThere are four ways to expand and collapse nodes:\n\n* Collapse All\n* Expand All\n* Moving Left or Right\n* Selecting a Search Result\n\nAs you move in and out of nodes (left or right) they will automatically expand\nor collapse for you. If you are like me and like to keep your treeview tidy\nlooking, you can use the collapse all. If you want to quickly see ALL of your\nnodes you can use the expand all. And if you are searching your tree and\nselect a search result the tree will be expanded so that you can see where\nthat node is.","children":[],"expanded":false},{"id":"gkosg1o6","title":"Collapse All","content":"Collapse All\n--------------------------------------------------------------------------------\n\nKey Binding: C\n\nThis will collapse all of your treeview nodes so that only the root nodes\nare visible. It is also a quick way to select the top-most root node!","children":[],"expanded":false},{"id":"a6mib1iz","title":"Expand All","content":"Expand All\n--------------------------------------------------------------------------------\n\nKey Binding: E\n\nThis will expand ALL the nodes within your treeview allowing you to quickly\nsee everything you have there.","children":[],"expanded":false}],"expanded":false},{"id":"2uwdlzdb","title":"Moving Nodes","content":"","children":[{"id":"mm800skt","title":"Moving a Node Up","content":"Moving a Node Up\n--------------------------------------------------------------------------------\n\nKey Binding: K\n\nUsing the K key will move the selected node up amongst its sibling nodes. It\nwill not move it out of the parent node even if you attempt to move a top most\nnode up again. To move it in or out of another node, use the move node left\nor right keys.","children":[],"expanded":false},{"id":"jlw1l2ut","title":"Moving a Node Down","content":"Moving a Node Down\n--------------------------------------------------------------------------------\n\nKey Binding: J\n\nUsing J will move the current node down among its siblings. To move it in or\nout of another node, use the move node left or right keys.","children":[],"expanded":false},{"id":"618subgw","title":"Moving a Node Left","content":"Moving a Node Left\n--------------------------------------------------------------------------------\n\nKey Binding: H\n\nUsing this key will cause the currently selected node to move up out of its\ncurrent parent node (rather it will move left). If it is a root node, this\nkey will have no effect.","children":[],"expanded":false},{"id":"98js4nmx","title":"Moving a Node Right","content":"Moving a Node Right\n--------------------------------------------------------------------------------\n\nKey Binding: L\n\nUsing the L key will cause the currently selected node to move into whichever\nsibling node is just above it (move right). If it is the only child node,\nthis key will have no effect.","children":[],"expanded":false}],"expanded":false}],"expanded":false},{"id":"0zb5ibtb","title":"Editor","content":"","children":[{"id":"mmwvu164","title":"Introduction to the Editor","content":"Introduction to the Editor\n--------------------------------------------------------------------------------\n\nThe editor in Httree is very basic. In time it may be expanded some, but the\ngoal of Httree is to be a straightforward, minimal, plain text editor that\nallows you to organize your information into a tree of topics grouped into\nfolders.","children":[],"expanded":false},{"id":"mn1y8eig","title":"Linking to Other Nodes","content":"Linking to Other Nodes\n--------------------------------------------------------------------------------\n\nYou can add links to your notes that will take the reader to other nodes\nwithin your notes system. To do so, type the caption for the node you want\nthe link to go to, wrapped in underscores. Here is an example:\n\n_Introduction_\n\nWhen in NORMAL mode, and this topic is selected, hit the # key.\nYou will see an Introduction link there, click that.\n\nRefer to the _Using the Links Dialog_ topic.","children":[],"expanded":false},{"id":"wp84y3qs","title":"Special Key Codes","content":"","children":[{"id":"00zndcy3","title":"Horizontal Rule","content":"Horizontal Rule\n--------------------------------------------------------------------------------\n\nYou can easily add an 80 character horizontal rule to the topic that you are\ncurrently editing.\n\nKey Binding: Ctrl+-","children":[],"expanded":false},{"id":"a17veptu","title":"Notes","content":"Notes\n--------------------------------------------------------------------------------\n\nIn the future more special key codes will be added to the editor, so be sure\nto keep current with the latest iteration of Httree.","children":[],"expanded":false}],"expanded":false},{"id":"n6ycvld5","title":"Find and Replace","content":"Find and Replace\n--------------------------------------------------------------------------------\n--------------------------------------------------------------------------------","children":[],"expanded":false}],"expanded":false}],"expanded":false},{"id":"eg9zuwag","title":"Saving","content":"","children":[{"id":"i4wn04ar","title":"Introduction to Saving","content":"Introduction to Saving\n--------------------------------------------------------------------------------\n\nDue to the fact that Httree is a stand alone .html file, saving is a bit\ndifferent from how a standard application would work. This is due to the\nlimitations in place with web browsers, for safety reasons (when visiting\nsites on the web).\n\nSaving is handled just as your browser would any other download. So however\nyou have it configured - is how it will behave.\n\nI personally set mine to use the Downloads directory, and generally if you\nsave more than once the browser will simply tack on an incrementing number to\nthe file names.\n\nThis is great because as you are working in Httree you can save often and have\na history of saves that you can rollback to if you need to.\n\nWhen you are done with an editing session - simply replace the original Httree\n.html file you opened with the latest 'save' of it.\n\nBe sure to consult the _Persistent Settings_ topic.","children":[],"expanded":false},{"id":"v3j26vjt","title":"Persistent Settings","content":"Persistent Settings\n--------------------------------------------------------------------------------\n\nWhen you save your Httree file, there are a couple of settings that save along\nwith the data:\n\n* Which tree nodes are expanded\n* The width of the treeview panel\n\nKeep this in mind if you are planning to distribute your Httree document.","children":[],"expanded":false},{"id":"swspph0r","title":"Save","content":"Save\n--------------------------------------------------------------------------------\n\nKey Binding: s\n\nThe s key (when you are not editing of course) saves the current Httree\ndocument using its default file name. Be sure to consult the _Save As_ topic.","children":[],"expanded":false},{"id":"uktkqftz","title":"Save As","content":"Save As\n--------------------------------------------------------------------------------\n\nKey Binding: S\n\nUsing S you can choose the file and then the current Httree is saved using\nthat. If you were to open that saved copy, you will find that the name you\nhad given it is now its default name, so you can simply use the _Save_\ncommand from then on.","children":[],"expanded":false}],"expanded":false},{"id":"n2qkli4t","title":"Configuration","content":"","children":[{"id":"zaxs1bxd","title":"Introduction to Configuration","content":"Introduction to Configuration\n--------------------------------------------------------------------------------\n\nHttree can be used for any number of purposes. One might be to create\nread-only documentation or help systems.","children":[],"expanded":false},{"id":"f08x2x2x","title":"Read Only Mode","content":"Read Only Mode\n--------------------------------------------------------------------------------\n\nIf you open up your Httree.html\nfile in a plain text editor, you can search for:\n\nconst readOnly\n\nIf you set its value to true your Httree.html file will be in read only mode\nwhen you open it. You can fold/unfold all the treeview nodes and search\nthrough the document as well as change the size of the treeview panel. However\nyou will not be able to create new nodes, delete nodes, edit notes, or use\nthe s and S key bindings.\n\nThe help dialog (via the ? key) will only show the commands that are allowed\nwhile in read only mode.","children":[],"expanded":false},{"id":"kmgwow1x","title":"Show Help on Open","content":"Show Help on Open\n--------------------------------------------------------------------------------\n\nSince Httree is a keyboard driven application, you may want to show the key\nbindings to the people who open your document. When it is first loaded the\nkey bindings are shown to them.\n\nIf you open your Httree file in a plain text editor, you can search for:\n\nconst showInitHelp\n\nIf you set its value to true that will enable the initial help.\nIf it becomes bothersome to people using your Httree document, they can simply\nset this value to false.","children":[],"expanded":false}],"expanded":false},{"id":"5e3phzej","title":"Linking","content":"","children":[{"id":"8tu8ax56","title":"Using the Links Dialog","content":"Using the Links Dialog\n--------------------------------------------------------------------------------\n\nKey Binding: #\n\nHttree makes it easier for you to access any http links OR links to other\nnodes or notes within your document by providing a links dialog.\n\nFor standard website links, you simply need to paste them wherever you like\nin your note text. Httree will detect those when you open the links dialog\nand add them to the links list.\n\nIf there are one or more links within the current note, use the Up/Down Arrows\nto select the link you want to go to, then hit Enter.","children":[],"expanded":false}],"expanded":true}
];

        let historyStack = [];
        let showingHistory = false;
        let historyIndex = 0;

        const showInitHelp = false;
        const readOnly = false;
        let selectedId = null;
        let editing = false;
        let showingLinks = false;
        let finding = false;
        let fileName = "help";

        let searchActive = false;
        let searchMatches = [];
        let searchIndex = 0;
        const searchDialog = document.getElementById('searchDialog');
        const searchInput = document.getElementById('searchInput');
        const searchList = document.getElementById('searchList');

        let findMatches = [];
        let findIndex = 0;


        //---- Utilities -------------------------------------------------------
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }
        function findNode(id) {
            for (const n of treeData) {
                if (n.id === id) return n;
            }
        }
        function findNodeAndParentById(id, nodes = treeData, parent = null) {
            for (const n of nodes) {
                if (n.id === id) return { node: n, parent };
                const res = findNodeAndParentById(id, n.children, n);
                if (res) return res;
            }
            return null;
        }
        function getSiblingsAndIndex(id) {
            const info = findNodeAndParentById(id);
            if (!info) return null;
            const siblings = info.parent ? info.parent.children : treeData;
            const index = siblings.findIndex(n => n.id === id);
            return { siblings, index, parent: info.parent };
        }
        function isFolder(n){ return (n.content || "").trim().length === 0; }
        function updateTitleFromContent(n){
            const firstLine = (n.content||"").split(/\r?\n/)[0].trim();
            if (firstLine) n.title = firstLine.slice(0, 80);
            else if (!n.title || !n.title.startsWith("New")) n.title = "New Folder";
        }
        function computePath(id){
            const segments = [];
            (function walk(id){
                const info = findNodeAndParentById(id);
                if (!info) return;
                if (info.parent) walk(info.parent.id);
                segments.push(info.node.title || "Untitled");
            })(id);
            return '/' + segments.join('/');
        }

        function recordHistory(id) {
            const node = findNodeAndParentById(id)?.node;
            if (!node) return;
            if (isFolder(node)) return; // only record notes
        
            // Remove any existing entry for this id
            historyStack = historyStack.filter(entry => entry.id !== id);
        
            // Add it at the end (latest)
            historyStack.push({ id, title: node.title || "(untitled)" });
        
            // Cap size at 100
            if (historyStack.length > 100) {
                historyStack.shift();
            }
        }


        //---- Rendering -------------------------------------------------------
        const treeEl = document.getElementById('tree');
        const editorArea = document.getElementById('editorArea');
        const modeEl = document.getElementById('mode');
        const kindEl = document.getElementById('kind');
        const pathEl = document.getElementById('path');

        function render(){
            // Render tree
            treeEl.innerHTML = '';
            const ul = document.createElement('ul');
            treeEl.appendChild(ul);

            function renderNode(n){
                const li = document.createElement('li');
                const row = document.createElement('div');
                row.className = 'node' + (n.id === selectedId ? ' selected' : '');

                // Twisty indicator
                const twist = document.createElement('span');
                twist.className = 'twisty';
                if (n.children.length) {
                    twist.innerHTML = n.expanded
                    ? `<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M1 3 L5 7 L9 3 Z" fill="currentColor" /></svg>`
                    : `<svg width="10" height="10" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M3 1 L7 5 L3 9 Z" fill="currentColor" /></svg>`;
                } else {
                    twist.innerHTML = `<svg width="6" height="6" viewBox="0 0 6 6" xmlns="http://www.w3.org/2000/svg"><circle cx="3" cy="3" r="1" fill="currentColor" /></svg>`;
                }

                // Icon
                const icon = document.createElement('span');
                icon.className = 'icon';
                icon.innerHTML = isFolder(n)
                    ? `<?xml version="1.0" encoding="UTF-8" standalone="no"?> <svg width="16" height="16" viewBox="0 0 4.2333334 4.2333334" version="1.1" id="svg5" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <g id="g5951" transform="matrix(0.18666667,0,0,0.18666667,-0.22930552,-0.10583338)"> <g id="layer1"> <path style="fill:#80a5ba;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" d="M 2.6458333,3.96875 H 11.90625 l 2.645833,2.6458332 h 7.9375 V 19.84375 H 2.6458333 Z" id="path65" /> <path style="fill:#466779;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" d="m 3.96875,5.2916667 h 7.408333 l 2.38125,2.38125 h 7.408334 V 18.520833 H 3.96875 Z" id="path924" /> <rect style="fill:#364750;fill-opacity:1;stroke-width:7.9375;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" id="rect1561" width="17.197916" height="9.260417" x="3.96875" y="9.260417" /> </g> </g> </svg>`
                    : `<?xml version="1.0" encoding="UTF-8" standalone="no"?> <!-- Created with Inkscape (http://www.inkscape.org/) --> <svg width="16" height="16" viewBox="0 0 4.2333334 4.2333334" version="1.1" id="svg5" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"> <defs id="defs2" /> <path style="fill:#80a5ba;fill-opacity:1;stroke-width:1.53367;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" d="m 0.79374997,0.63637699 c 1.76898013,-0.006197 0.91709523,0 2.64583343,0 V 3.5997107 H 0.79374997 Z" id="path65" /> <path style="fill:#787878;fill-opacity:1;stroke-width:1.22694;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" d="m 1.0583332,0.93243487 c 1.4151843,-0.004957 0.7336763,0 2.116667,0 V 3.303102 h -2.116667 z" id="path4404" /> <rect style="fill:#364750;fill-opacity:1;stroke-width:1.53367;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" id="rect5117" width="1.0583334" height="0.24694447" x="1.5875001" y="1.3772104" /> <rect style="fill:#364750;fill-opacity:1;stroke-width:1.53367;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" id="rect5737" width="1.0583334" height="0.24694447" x="1.5875001" y="1.8710994" /> <rect style="fill:#364750;fill-opacity:1;stroke-width:1.53367;stroke-linecap:round;stroke-linejoin:round;paint-order:stroke fill markers" id="rect5739" width="1.0583334" height="0.24694447" x="1.5875001" y="2.3649883" /> </svg>`;

                const title = document.createElement('span');
                title.className = 'title';
                title.textContent = n.title || '(untitled)';

                row.appendChild(twist); row.appendChild(icon); row.appendChild(title);
                row.addEventListener('click', () => { selectedId = n.id; render(); });

                li.appendChild(row);

                if (n.expanded && n.children.length){
                    const inner = document.createElement('ul');
                    for (const c of n.children) inner.appendChild(renderNode(c));
                    li.appendChild(inner);
                }
                return li;
            }

            for (const n of treeData) ul.appendChild(renderNode(n));

            // Render editor status + content
            const selInfo = findNodeAndParentById(selectedId);
            if (selInfo){
                pathEl.textContent = computePath(selInfo.node.id);
                kindEl.textContent = isFolder(selInfo.node) ? 'FOLDER' : 'FILE';
                if (!editing) {
                    editorArea.value = safeRestoreText(selInfo.node.content) || '';
                    editorArea.setAttribute('readonly', 'readonly');
                } else {
                    editorArea.removeAttribute('readonly');
                    // keep as-is while editing
                }
            } else {
                pathEl.textContent = '/';
                kindEl.textContent = '—';
                editorArea.value = '';
                editorArea.setAttribute('readonly', 'readonly');
            }

            modeEl.textContent = editing ? 'INSERT' : 'NORMAL';

            if (selectedId) recordHistory(selectedId);

            // Ensure selected node is visible
            setTimeout(() => {
                const selEl = document.querySelector('.node.selected');
                if (selEl) selEl.scrollIntoView({ block: "nearest" });
            }, 0);
        }


        //---- Editor Sync -----------------------------------------------------
        editorArea.addEventListener('input', () => {
            syncFile();
        });

        function syncFile() {
            const info = findNodeAndParentById(selectedId);
            if (!info) return;
            info.node.content = safeStoreText(editorArea.value);
            updateTitleFromContent(info.node);
            // File vs folder might have changed; keep UI responsive
            render();
        }


        function safeStoreText(text) {
            if (!text) return "";
            return text
                .replace(/<\/script/gi, "<\\/script")   // prevent script tag breakouts
                .replace(/<\/style/gi, "<\\/style")     // style tag safety
                .replace(/]]>/g, "]]\\>");              // prevent CDATA close
        }
        
        function safeRestoreText(text) {
            if (!text) return "";
            return text
                .replace(/<\\\/script/gi, "</script")
                .replace(/<\\\/style/gi, "</style")
                .replace(/]]\\>/g, "]]>");
        }


        editorArea.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                editing = false;
                editorArea.blur();
                render();
            }
        });


        //---- Commands --------------------------------------------------------
        function ensureSelection(){ if (!selectedId && treeData[0]) selectedId = treeData[0].id; }

        function addRoot(){
            const node = { id: makeId(), title: 'New Folder', content: '', children: [], expanded: true };
            treeData.push(node);
            selectedId = node.id;
        }
        function addAfter(){
            ensureSelection();
            const ctx = getSiblingsAndIndex(selectedId);
            if (!ctx) return;
            const node = { id: makeId(), title: 'New Folder', content: '', children: [], expanded: true };
            ctx.siblings.splice(ctx.index + 1, 0, node);
            selectedId = node.id;
        }
        function addChild(){
            ensureSelection();
            const info = findNodeAndParentById(selectedId);
            if (!info) return;
            info.node.expanded = true;
            const node = { id: makeId(), title: 'New Folder', content: '', children: [], expanded: true };
            info.node.children.push(node);
            selectedId = node.id;
        }
        function renameFolder() {
            ensureSelection();
            let selectedNode = findNodeAndParentById(selectedId).node;
            if (isFolder(selectedNode)) {
                let newName = prompt('Enter new folder name:', selectedNode.name);
                if (!newName) { return; }
                selectedNode.title = newName;
                render();
            }
        }
        function selectNextSibling(curLevelOnly) {
            const info = findNodeAndParentById(selectedId);
            if (!info) return;
        
            // Case 1: current is a folder with children
            if (!curLevelOnly) {
                if (isFolder(info.node) && info.node.children.length) {
                    if (!info.node.expanded) {
                        info.node.expanded = true; // expand if collapsed
                    }
                    selectedId = info.node.children[0].id;
                    return;
                }
            }
        
            // Case 2: move to next sibling at this level
            const ctx = getSiblingsAndIndex(selectedId);
            if (!ctx) return;
            if (ctx.index < ctx.siblings.length - 1) {
                selectedId = ctx.siblings[ctx.index + 1].id;
                return;
            }
        
            // Case 3: last sibling → climb ancestors until one has a next sibling
            if (!curLevelOnly) {
                let ancestorId = ctx.parent ? ctx.parent.id : null;
                while (ancestorId) {
                    const actx = getSiblingsAndIndex(ancestorId);
                    if (!actx) break;
            
                    if (actx.index < actx.siblings.length - 1) {
                        selectedId = actx.siblings[actx.index + 1].id;
                        return;
                    }
            
                    // go up another level
                    ancestorId = actx.parent ? actx.parent.id : null;
                }
            }
        }
        function selectPrevSibling(curLevelOnly) {
            const ctx = getSiblingsAndIndex(selectedId);
            if (!ctx) return;
        
            // If we are the first child, go to parent instead
            if (!curLevelOnly) {
                if (ctx.index === 0 && ctx.parent) {
                    selectedId = ctx.parent.id;
                    return;
                }
            }
        
            // Otherwise go to previous sibling
            const prev = Math.max(ctx.index - 1, 0);
            selectedId = ctx.siblings[prev].id;
        }
        function expandOrFirstChild(){
            const info = findNodeAndParentById(selectedId); if (!info) return;
            if (info.node.children.length && !info.node.expanded) {
                info.node.expanded = true;
            } else if (info.node.children.length) {
                selectedId = info.node.children[0].id;
            }
        }
        function collapseCurrent(){
            const info = findNodeAndParentById(selectedId); if (!info) return;
            if (info.node.expanded) info.node.expanded = false; else if (info.parent) selectedId = info.parent.id;
        }
        function collapseAll(){
            (function walk(list){
                for (const n of list){ n.expanded = false; walk(n.children); }
            })(treeData);
            selectedId = treeData[0].id;
        }
        function expandAll(){
            (function walk(list){
                for (const n of list){ n.expanded = true; walk(n.children); }
            })(treeData);
        }
        function gotoTop(){
            selectedId = treeData[0].id;
            treeEl.scrollTo(0, 0, "smooth");
        }
        function gotoBottom(){
            selectedId = treeData[treeData.length-1].id;
            treeEl.scrollTo(0, treeEl.scrollHeight, "smooth");
        }
        function moveOutToParent(){
            const ctx = getSiblingsAndIndex(selectedId); if (!ctx || !ctx.parent) return; // already root
            // Remove from current siblings
            const [node] = ctx.siblings.splice(ctx.index, 1);
            // Insert after parent in its own siblings list
            const pctx = getSiblingsAndIndex(ctx.parent.id);
            const insertAt = pctx.index + 1;
            pctx.siblings.splice(insertAt, 0, node);
            selectedId = node.id;
        }
        function moveIntoAsChild(){
            const info = findNodeAndParentById(selectedId); if (!info) return;
            // Move selected under some other selected? Spec: 'L' moves the current node into the currently selected node, as a child.
            // Since there's only one selection, interpret as: move the node into its next sibling if any; else do nothing.
            // Better: if the node has a previous sibling, move it into that sibling (common Vim tree behavior with L)?
            // But spec says: into the currently selected node — that's the node itself; so allow moving the PREVIOUS sibling into CURRENT with hotkey on that previous sibling would be impossible.
            // We'll interpret L as: if there is a previous sibling, move this node into that previous sibling as a child; otherwise if current has a next sibling, move into that. If neither, no-op.

            const ctx = getSiblingsAndIndex(selectedId); if (!ctx) return;
            const target = ctx.siblings[ctx.index - 1] || ctx.siblings[ctx.index + 1];
            if (!target) return;
            if (!Array.isArray(target.children)) target.children = [];
            target.expanded = true;
            const [node] = ctx.siblings.splice(ctx.index, 1);
            target.children.push(node);
            selectedId = node.id;
        }
        function reorderAmongSiblings(dir){
            const ctx = getSiblingsAndIndex(selectedId); if (!ctx) return;
            const newIndex = ctx.index + (dir === 'down' ? 1 : -1);
            if (newIndex < 0 || newIndex >= ctx.siblings.length) return;
            const [node] = ctx.siblings.splice(ctx.index, 1);
            ctx.siblings.splice(newIndex, 0, node);
            selectedId = node.id;
        }
        function deleteNode(){
            const ctx = getSiblingsAndIndex(selectedId); if (!ctx) return;
            const goTo = ctx.siblings[ctx.index + 1] || ctx.siblings[ctx.index - 1] || ctx.parent || treeData[0] || null;
            ctx.siblings.splice(ctx.index, 1);
            selectedId = goTo ? (goTo.id || goTo) : null;
        }
        function resizeTree(adjustment){
            const app = document.querySelector('.app');
            if (!app) return;

            // Get the current grid-template-columns value
            const style = window.getComputedStyle(app);
            const gridCols = style.getPropertyValue('grid-template-columns').split(' ');

            // Parse the first column (tree width)
            let treeWidth = parseInt(gridCols[0]);
            if (isNaN(treeWidth)) return;

            treeWidth += adjustment;

            if (treeWidth < 240) {
                treeWidth = 240;
            }

            // Update the grid-template-columns
            app.style.gridTemplateColumns = `${treeWidth}px 1fr`;
        }
        function insertHr() {
            const insertText = "--------------------------------------------------------------------------------";
            const start = editorArea.selectionStart;
            const end = editorArea.selectionEnd;

            // Insert at the cursor position
            const text = editorArea.value;
            editorArea.value = text.slice(0, start) + insertText + text.slice(end);

            // Move the cursor to the end of the inserted text
            editorArea.selectionStart = editorArea.selectionEnd = start + insertText.length;

            syncFile();
        }


        //---- Links -----------------------------------------------------------
        function openLinksDialog() {
            showingLinks = true;
            const info = findNodeAndParentById(selectedId);
            if (!info || !info.node.content) return;

            const content = safeRestoreText(info.node.content);
            const urlRegex = /\bhttps?:\/\/[^\s]+/gi;
            const nodeLinkRegex = /_(.+?)_/g;

            const urlMatches = content.match(urlRegex) || [];

            // Collect node links
            let nodeMatches = [];
            let match;
            while ((match = nodeLinkRegex.exec(content)) !== null) {
                nodeMatches.push(match[1]);
            }

            const listEl = document.getElementById('linksList');
            listEl.innerHTML = '';

            if (urlMatches.length === 0 && nodeMatches.length === 0) {
                listEl.innerHTML = '<p>No links found.</p>';
            } else {
                // Render URL links
                urlMatches.forEach(url => {
                    const a = document.createElement('a');
                    a.href = url;
                    a.target = '_blank';
                    a.textContent = url;
                    listEl.appendChild(a);
                    listEl.appendChild(document.createElement('br'));
                });

                // Render Node links
                nodeMatches.forEach(title => {
                    const lowerTitle = title.toLowerCase();
                    let foundNode = null;

                    // Search only node titles (like `:query`)
                    (function walk(nodes) {
                        for (const n of nodes) {
                            if (n.title && n.title.toLowerCase() === lowerTitle) {
                                foundNode = n;
                                return;
                            }
                            if (n.children && n.children.length) walk(n.children);
                            if (foundNode) return; // early exit if found
                        }
                    })(treeData);

                    const link = document.createElement('a');
                    link.href = '#';
                    link.textContent = title;

                    if (foundNode) {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            expandToNode(foundNode.id);
                            selectedId = foundNode.id;
                            closeLinksDialog();
                            render();
                        });
                    } else {
                        link.style.color = '#888';
                        link.title = 'Node not found';
                    }

                    listEl.appendChild(link);
                    listEl.appendChild(document.createElement('br'));
                });
            }

            document.getElementById('linksDialog').style.display = 'block';
        }

        function closeLinksDialog() {
            showingLinks = false;
            document.getElementById('linksDialog').style.display = 'none';
        }

        function openHistoryDialog() {
            showingHistory = true;
            historyIndex = 0;
            renderHistoryList();
            document.getElementById('historyDialog').style.display = 'block';
        }
        
        function closeHistoryDialog() {
            showingHistory = false;
            document.getElementById('historyDialog').style.display = 'none';
        }
        
        function renderHistoryList() {
            const listEl = document.getElementById('historyList');
            listEl.innerHTML = '';
            const recent = historyStack.slice(-15).reverse(); // latest first
            recent.forEach((entry, i) => {
                const div = document.createElement('div');
                div.textContent = entry.title;
                if (i === historyIndex) {
                    div.classList.add('selected');
                    div.style.background = '#444'; // ensure visible
                }
                listEl.appendChild(div);
            });
        }





        //---- Finding and Replacing -------------------------------------------
        function openReplaceDialog() {
            finding = true;
            document.getElementById('searchText').value = '';
            document.getElementById('replaceText').value = '';
            document.getElementById('replaceDialog').style.display = 'block';
            document.getElementById('searchText').focus();
        }

        function closeReplaceDialog() {
            finding = false;
            document.getElementById('replaceDialog').style.display = 'none';
        }

        function doFind() {
            const info = findNodeAndParentById(selectedId);
            if (!info) return;

            const searchVal = document.getElementById('searchText').value;
            const resultsEl = document.getElementById('replaceResults');
            const area = document.getElementById('editorArea');

            if (!searchVal) {
                resultsEl.textContent = 'Enter something to search for.';
                return;
            }

            const content = safeRestoreText(info.node.content) || '';
            // Escape user input for regex
            const regex = new RegExp(searchVal.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

            // Create a list of match start indexes
            findMatches = [];
            let match;
            while ((match = regex.exec(content)) !== null) {
                findMatches.push({ start: match.index, end: match.index + match[0].length });
            }

            if (findMatches.length === 0) {
                resultsEl.textContent = 'No matches found.';
                return;
            }

            // Cycle to the next match
            if (findIndex >= findMatches.length) findIndex = 0;
            const current = findMatches[findIndex];

            // Move the caret/selection to the match
            area.focus();
            area.setSelectionRange(current.start, current.end);

            resultsEl.textContent = `Match ${findIndex + 1} of ${findMatches.length}`;
            findIndex++;
        }

        function doReplaceAll() {
            const info = findNodeAndParentById(selectedId);
            if (!info) return;

            const searchVal = document.getElementById('searchText').value;
            const replaceVal = document.getElementById('replaceText').value;
            const resultsEl = document.getElementById('replaceResults');

            if (!searchVal) {
                resultsEl.textContent = 'Enter something to search for.';
                return;
            }

            const regex = new RegExp(searchVal.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
            let content = safeRestoreText(info.node.content) || '';
            const matchCount = (content.match(regex) || []).length;

            if (matchCount > 0) {
                content = content.replace(regex, replaceVal);
                safeStoreText(info.node.content) = content;
                render();
                resultsEl.textContent = `Replaced ${matchCount} occurrence(s).`;
            } else {
                resultsEl.textContent = 'No matches found.';
            }
        }

        const searchInputEl = document.getElementById('searchText');
        const replaceInputEl = document.getElementById('replaceText');

        replaceInputEl.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
                e.preventDefault();
                doReplaceAll(); // replaces all
                closeReplaceDialog();
            }
        });









        //---- Search ----------------------------------------------------------
        function openSearch() {
            searchActive = true;
            searchDialog.style.display = 'flex';
            searchInput.value = '';
            searchInput.focus();
            searchMatches = [];
            searchIndex = 0;
            renderSearchList();
        }

        function closeSearch() {
            searchActive = false;
            searchDialog.style.display = 'none';
        }

        function searchTree(query) {
            searchMatches = [];
            const matchContent = !query.startsWith(':');
            const q = query.startsWith(':') ? query.slice(1).toLowerCase() : query.toLowerCase();
            (function walk(nodes) {
                for (const n of nodes) {
                    if ((n.title && n.title.toLowerCase().includes(q)) || (matchContent && n.content && n.content.toLowerCase().includes(q))) {
                        searchMatches.push(n);
                    }
                    if (n.children && n.children.length) walk(n.children);
                }
            })(treeData);
            searchIndex = 0;
            renderSearchList();
        }

        function renderSearchList() {
            searchList.innerHTML = '';
            searchMatches.forEach((n, i) => {
                const item = document.createElement('div');
                item.textContent = n.title || '(untitled)';
                if (i === searchIndex) item.classList.add('selected');
                item.addEventListener('click', () => {
                    selectSearchResult(i);
                });
                searchList.appendChild(item);
            });
            if (searchMatches.length === 0) {
                const empty = document.createElement('div');
                empty.textContent = '(no matching nodes)';
                empty.style.color = '#888';
                searchList.appendChild(empty);
            }
        }

        function selectSearchResult(i) {
            if (i < 0 || i >= searchMatches.length) return;
            searchIndex = i;
            expandToNode(searchMatches[i].id);
            selectedId = searchMatches[i].id;
            render();
            renderSearchList();
        }

        function expandToNode(id) {
            let info = findNodeAndParentById(id);
            while (info && info.parent) {
                info.parent.expanded = true;
                info = findNodeAndParentById(info.parent.id);
            }
        }

        searchInput.addEventListener('input', e => {
            searchTree(e.target.value);
        });

        searchInput.addEventListener('keydown', e => {
            if (e.key === 'ArrowDown') {
                searchIndex = Math.min(searchIndex + 1, searchMatches.length - 1);
                renderSearchList();
                e.preventDefault();
            } else if (e.key === 'ArrowUp') {
                searchIndex = Math.max(searchIndex - 1, 0);
                renderSearchList();
                e.preventDefault();
            } else if (e.key === 'Enter') {
                if (searchMatches.length > 0) {
                    selectSearchResult(searchIndex);
                    closeSearch();
                }
            } else if (e.key === 'Escape' || e.key === 'q') {
                closeSearch();
            }
        });


        function saveAsHtml(currentFileName) {
            let name = currentFileName;
            let saveName = false;
            if (name === "") {
                name = prompt("Save as .html (enter name without extension):", "");
                if (!name) return;
                saveName = true;
            }

            const elemLimit = 20; // Number of elements per line
            const htmlDoc = document.documentElement.cloneNode(true);

            // Make sure the latest database is stored
            const latestDatabase = JSON.parse(JSON.stringify(treeData));

            const lines = [];
            for (let i = 0; i < latestDatabase.length; i += elemLimit) {
                let chunk = latestDatabase.slice(i, i + elemLimit);
                lines.push(JSON.stringify(chunk).slice(1, -1)); // Strip [ and ]
            }
            let formattedDatabase = `[\n  ${lines.join(",\n  ")}\n]`;

            // Ensure correct replacement of the old database
            let htmlContent = "<!DOCTYPE html>" + htmlDoc.outerHTML;
            if (saveName) {
                htmlContent = htmlContent.replace(/let\s+fileName\s*=\s*"([^"]*)";/, `let fileName = "${name}";`);
            }
            htmlContent = htmlContent.replace(/let\s+treeData\s*=\s*\[[\s\S]*?\];/, `let treeData = ${formattedDatabase};`);

            let blob = new Blob([htmlContent], { type: "text/html" });
            let a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = `${name}.html`;
            a.click();
        }


        //---- Key Handling ----------------------------------------------------
        function handleGlobalKey(e){
            if (editing) {
                // Check if Ctrl (or Command on Mac) is held and the "-" key is pressed
                if ((e.ctrlKey || e.metaKey) && (e.key === "-" || e.code === "Minus")) {
                    e.preventDefault(); // optional: prevents browser zoom-out
                    insertHr();
                }

                return;
            }
            if (e.ctrlKey || e.metaKey || e.altKey) return;

            if (finding) {
                switch (e.key) {
                    case 'Escape':
                        closeReplaceDialog();
                        break;

                    case "Enter":
                        doFind();
                        break;
                }

                return;
            }

            if (e.key === '/') {
                openSearch();
                e.preventDefault();
                return;
            }

            if (searchActive) return;

            const k = e.key; // compare exact letter; do not rely on shift state
            let did = true;
            switch (k) {
                case 'i':
                    if (!readOnly) {
                        const info = findNodeAndParentById(selectedId); if (!info) return;
                        editing = true; render();
                        editorArea.focus();
                        // editorArea.setSelectionRange(editorArea.value.length, editorArea.value.length);
                    }
                    break;
                case 'Escape':
                    if (showingLinks) {
                        closeLinksDialog();
                        e.preventDefault();
                    }
                    else {
                        did = false;
                    }
                    break; // handled in textarea
                case 'f': openReplaceDialog(); break;
                case 'r': if (!readOnly) addRoot(); break;
                case 'R': if (!readOnly) renameFolder(); break;
                case 'j': selectNextSibling(false); break;
                case 'k': selectPrevSibling(false); break;
                case ',': selectNextSibling(true); break;
                case '.': selectPrevSibling(true); break;
                case 'l': expandOrFirstChild(); break;
                case 'h': collapseCurrent(); break;
                case 'C': collapseAll(); break;
                case 'E': expandAll(); break;
                case 'g': gotoTop(); break;
                case 'G': gotoBottom(); break;
                case 'A': if (!readOnly) addChild(); break;
                case 'a': if (!readOnly) addAfter(); break;
                case 'H': if (!readOnly) moveOutToParent(); break;
                case 'L': if (!readOnly) moveIntoAsChild(); break;
                case 'J': if (!readOnly) reorderAmongSiblings('down'); break;
                case 'K': if (!readOnly) reorderAmongSiblings('up'); break;
                case 'D': if (!readOnly) deleteNode(); break;
                case 's': if (!readOnly) saveAsHtml(fileName); break;
                case 'S': if (!readOnly) saveAsHtml(""); break;
                case ']': resizeTree(30); break;
                case '[': resizeTree(-30); break;
                case '#': openLinksDialog(); break;
                case 'X': openMissingLinksDialog(); break;
                case '<':
                    openHistoryDialog();
                    e.preventDefault();
                    return;
                default: did = false; break;
            }
            if (did) { e.preventDefault(); render(); }
        }

        document.addEventListener('keydown', e => {
            if (e.key === '?' && !editing) {
                document.getElementById('helpDialog').style.display = 'block';
                e.preventDefault();
                return;
            }

            if (e.key === 'Escape') {
                repeatCount = 1;

                if (document.getElementById('helpDialog').style.display === 'block') {
                    document.getElementById('helpDialog').style.display = 'none';
                    e.stopPropagation();
                    return;
                } else {
                    selectedNode = null;
                }
            }
        });

        window.addEventListener('keydown', handleGlobalKey, { capture: true });

        function escapeForScript(json){
            return json.replace(/<\//g, '<\\/'); // avoid closing script tags
        }

        //---- Init ------------------------------------------------------------
        window.addEventListener('load', function() {
            render();

            if (readOnly) {
                document.getElementById('authorHelp').style.display = 'none';
                document.getElementById('readerHelp').style.display = 'block';
                document.getElementById('mode').style.display = 'none';
                document.getElementById('replaceTools').style.display = 'none';
            } else {
                document.getElementById('authorHelp').style.display = 'block';
                document.getElementById('readerHelp').style.display = 'none';
                document.getElementById('mode').style.display = 'block';
                document.getElementById('replaceTools').style.display = 'block';
            }

            if (showInitHelp) {
                document.getElementById('helpDialog').style.display = 'block';
            }

            selectedId = treeData[0]?.id || null;
        });
    
    let linksIndex = 0;
    let linksCount = 0;

    function openLinksDialog() {
        showingLinks = true;
        linksIndex = 0;
        const info = findNodeAndParentById(selectedId);
        if (!info || !info.node.content) return;

        const content = safeRestoreText(info.node.content);
        const urlRegex = /\bhttps?:\/\/[^\s]+/gi;
        const nodeLinkRegex = /_(.+?)_/g;

        const urlMatches = content.match(urlRegex) || [];

        let nodeMatches = [];
        let match;
        while ((match = nodeLinkRegex.exec(content)) !== null) {
            nodeMatches.push(match[1]);
        }

        // Deduplicate using Set
        const uniqueUrls = [...new Set(urlMatches)];
        const uniqueNodes = [...new Set(nodeMatches.map(n => n.trim()))];

        const listEl = document.getElementById('linksList');
        listEl.innerHTML = '';

        if (uniqueUrls.length === 0 && uniqueNodes.length === 0) {
            listEl.innerHTML = '<p>No links found.</p>';
        } else {
            uniqueUrls.forEach(url => {
                const a = document.createElement('a');
                a.href = url;
                a.target = '_blank';
                a.textContent = url;
                listEl.appendChild(a);
            });

            uniqueNodes.forEach(title => {
                const lowerTitle = title.toLowerCase();
                let foundNode = null;

                (function walk(nodes) {
                    for (const n of nodes) {
                        if (n.title && n.title.toLowerCase() === lowerTitle) {
                            foundNode = n;
                            return;
                        }
                        if (n.children && n.children.length) walk(n.children);
                        if (foundNode) return;
                    }
                })(treeData);

                const link = document.createElement('a');
                link.href = '#';
                link.textContent = title;

                if (foundNode) {
                    link.dataset.nodeId = foundNode.id;
                } else {
                    link.style.color = '#888';
                    link.title = 'Node not found';
                }

                listEl.appendChild(link);
            });
        }

        const links = listEl.querySelectorAll('a');
        linksCount = links.length;
        if (linksCount > 0) {
            links[0].classList.add('selected');
        }

        document.getElementById('linksDialog').style.display = 'block';
    }

    function openMissingLinksDialog() {
        showingLinks = true;
        const nodeLinkRegex = /_(.+?)_/g;

        // Gather all node titles (case-insensitive)
        const allTitles = new Set();
        (function walkTitles(nodes) {
            for (const n of nodes) {
                if (n.title) {
                    allTitles.add(n.title.trim().toLowerCase());
                }
                if (n.children && n.children.length) walkTitles(n.children);
            }
        })(treeData);

        // Map of missingLink → set of nodes that reference it
        const missingMap = new Map();

        (function walk(nodes) {
            for (const n of nodes) {
                if (n.content) {
                    let seenInThisNode = new Set(); // avoid dupes within the same note
                    let match;
                    while ((match = nodeLinkRegex.exec(n.content)) !== null) {
                        const linkTitle = match[1].trim();
                        if (!allTitles.has(linkTitle.toLowerCase())) {
                            if (!seenInThisNode.has(linkTitle.toLowerCase())) {
                                if (!missingMap.has(linkTitle)) {
                                    missingMap.set(linkTitle, []);
                                }
                                missingMap.get(linkTitle).push({
                                    nodeId: n.id,
                                    nodeTitle: n.title || '(untitled)'
                                });
                                seenInThisNode.add(linkTitle.toLowerCase());
                            }
                        }
                    }
                }
                if (n.children && n.children.length) walk(n.children);
            }
        })(treeData);

        const listEl = document.getElementById('linksList');
        listEl.innerHTML = '';

        if (missingMap.size === 0) {
            listEl.innerHTML = '<p>No missing links found 🎉</p>';
        } else {
            listEl.innerHTML = '<p>Missing Links:</p>';
            for (const [missingTitle, refs] of missingMap.entries()) {
                refs.forEach(ref => {
                    const container = document.createElement('div');

                    const link = document.createElement('a');
                    link.href = '#';
                    link.textContent = `"${missingTitle}" — linked from: ${ref.nodeTitle}`;
                    link.style.color = '#888';
                    link.title = 'Missing link — click to go to note';

                    // Clicking takes you to the referencing note
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        expandToNode(ref.nodeId);
                        selectedId = ref.nodeId;
                        closeLinksDialog();
                        render();
                    });

                    container.appendChild(link);
                    listEl.appendChild(container);
                });
            }
        }

        document.getElementById('linksDialog').style.display = 'block';
    }

    function activateSelectedLink() {
        const listEl = document.getElementById('linksList');
        const links = listEl.querySelectorAll('a');
        if (linksIndex < 0 || linksIndex >= links.length) return;
        const link = links[linksIndex];
        if (link.dataset.nodeId) {
            expandToNode(link.dataset.nodeId);
            selectedId = link.dataset.nodeId;
            closeLinksDialog();
            render();
        } else {
            link.click();
        }
    }

    function handleLinksKey(e) {
        if (!showingLinks) return;
        const listEl = document.getElementById('linksList');
        const links = listEl.querySelectorAll('a');
        if (links.length === 0) return;

        if (e.key === 'ArrowDown') {
            links[linksIndex].classList.remove('selected');
            linksIndex = (linksIndex + 1) % links.length;
            links[linksIndex].classList.add('selected');
            e.preventDefault();
        } else if (e.key === 'ArrowUp') {
            links[linksIndex].classList.remove('selected');
            linksIndex = (linksIndex - 1 + links.length) % links.length;
            links[linksIndex].classList.add('selected');
            e.preventDefault();
        } else if (e.key === 'Enter') {
            activateSelectedLink();
            e.preventDefault();
        } else if (e.key === 'Escape') {
            closeLinksDialog();
            e.preventDefault();
        }
    }

    function handleHistoryKey(e) {
        if (!showingHistory) return;
        if (e.key === 'ArrowDown') {
            historyIndex = Math.min(historyIndex + 1, Math.min(14, historyStack.length - 1));
            renderHistoryList();
            e.preventDefault();
        } else if (e.key === 'ArrowUp') {
            historyIndex = Math.max(historyIndex - 1, 0);
            renderHistoryList();
            e.preventDefault();
        } else if (e.key === 'Enter') {
            const recent = historyStack.slice(-15).reverse();
            if (recent[historyIndex]) {
                expandToNode(recent[historyIndex].id);
                selectedId = recent[historyIndex].id;
                closeHistoryDialog();
                render();
            }
            e.preventDefault();
        } else if (e.key === 'Escape' || e.key === 'q') {
            closeHistoryDialog();
            e.preventDefault();
        }
        return;
    }

    window.addEventListener('keydown', handleHistoryKey, { capture: true });
    window.addEventListener('keydown', handleLinksKey, { capture: true });
</script>
</body></html>
